---
title: Functions
sidebar_label: Intro to Functions
description: "Learn about functions in Go - from defining and calling functions to understanding parameters and return values."
---

# Functions
Functions are reusable blocks of code that perform a specific task. In Go, you can define a function using the `func` keyword followed by the function name, parameters (if any), and return type (if any).

```go
func functionName(parameters) returnType {
    // function body
}
```

To make easier to read the code the variable type comes after the variable name
```go
func add(a int, b int) int {
    return a + b
}
```
In the above example, `add` is a function that takes two integer parameters `a` and `b`, and returns an integer which is the sum of `a` and `b`. Also in above example `func add(a int, b int) int` is called as `function signature`

## Multiple Parameters
When multiple parameters have the same type and are next to each other in the function signature, the type needs to be declared after the last argument only.

```go
func addToDatabase(name, email string) {
    // function body
}
```

```go
func addToDatabase(name, email string, id int) {
  // ?
}
```

```go
func addToDatabase(name, email string, id int, address string) {
  // ?
}
```

## Passing Variables by Value
In Go, when you pass a variable to a function, you are passing a copy of that variable. This means that any changes made to the variable inside the function do not affect the original variable outside the function.

```go
func increment(x int) {
    x++
}
func main() {
    num := 5
    increment(num)
    fmt.Println(num) // Output: 5
    // because the increment function receives a copy of num, so the original num remains unchanged
}
```

## Ignoring Return Values
If a function returns a value but you don't need it, you can ignore it using the blank identifier `_`.

```go
func getUser() (string, int) {
    return "Alice", 30
}
func main() {
    name, _ := getUser() // We only care about the name, so we ignore the age
    fmt.Println(name) // Output: Alice
}
```

## Named Return Values
Return values are the values that a function sends back to the caller after it finishes executing. In Go, you can name the return values in the function signature, which allows you to return values without explicitly specifying them in the return statement.

<br />
> A return statement without arguments returns the named return values. This is known as a "naked" return. Naked return statements should be used only in short functions. They can harm readability in longer functions.

<br />
```go
func getCoords() (x, y int) {
	// x and y are initialized with zero values

	return // automatically returns x and y
}
```
Is same as:
```go
func getCoords() (int, int) {
	var x int
	var y int
	return x, y
}
```

## The benefits of Named Returns
### Good for documentation (Understanding)
Named return parameters are particularly important in longer functions with many return values.

```go
func calculator(a, b int) (mul, div int, err error) {
    if b == 0 {
      return 0, 0, errors.New("can't divide by zero")
    }
    mul = a * b
    div = a / b
    return mul, div, nil
}
```
Which is easier to understand than:

```go
func calculator(a, b int) (int, int, error) {
    if b == 0 {
      return 0, 0, errors.New("can't divide by zero")
    }
    mul := a * b
    div := a / b
    return mul, div, nil
}
```

### Less Code (Writing)
Named return values can reduce the amount of code you need to write, especially when you have multiple return values. You can simply assign values to the named return parameters and use a naked return statement.

## Explicit Returns
Even though a function has named return values, we can still explicity return values if we want to.

```go
func getCoords() (x, y int) {
    return x, y // explicitly returning x and y
}
```

We can override the return values
```go
func getCoords() (x, y int) {
    return 5, 6 // this is explicit, x any y are NOT returned
}
```

Otherwise we can just use the named return values and a naked return statement
```go
func getCoords() (x, y int) {
    return // implicity returns x and y with their zero values (0, 0)
}   
``` 

## Function As Values
In Go, functions are first-class citizens, which means they can be treated like any other value. You can assign a function to a variable, pass it as an argument to another function, or even return it from a function.

```go
func add(a, b int) int {
    return a + b
}  

func mult(x, y int) int {
    return x * y
}

func main() {
    // Assigning a function to a variable
    operation := add
    fmt.Println(operation(2, 3)) // Output: 5

    // Passing a function as an argument
    result := performOperation(4, 5, mult)
    fmt.Println(result) // Output: 20
} 
func performOperation(a, b int, op func(int, int) int) int {
    return op(a, b)
}
```

## Anonymous Functions
Anonymous functions are functions that do not have a name. They're useful when defining a function that will only be used once or to create a quick closure.

```go
func conversions(converter func(int) int, x, y, z int) (int, int, int) {
	convertedX := converter(x)
	convertedY := converter(y)
	convertedZ := converter(z)
	return convertedX, convertedY, convertedZ
}
```

We could define a function normally and then pass it in by name... but it's usually easier to just define it anonymously:

```go
func double(a int) int {
    return a + a
}

func main() {
    // using a named function
	newX, newY, newZ := conversions(double, 1, 2, 3)
	// newX is 2, newY is 4, newZ is 6

    // using an anonymous function
	newX, newY, newZ = conversions(func(a int) int {
	    return a + a
	}, 1, 2, 3)
	// newX is 2, newY is 4, newZ is 6
}
```

## Defer Statement
It is a feature in Go that allows us to call a particular function at the time when the main function finishes executing and planning to return. The deferred function will be executed after the surrounding function returns, but before the actual return value is sent back to the caller.

```go
func GetUsername(dstName, srcName string) (username string, err error) {
	// Open a connection to a database
	conn, _ := db.Open(srcName)

	// Close the connection *anywhere* the GetUsername function returns
	defer conn.Close()

	username, err = db.FetchUser()
	if err != nil {
		// The defer statement is auto-executed if we return here
		return "", err
	}

	// The defer statement is auto-executed if we return here
	return username, nil
}
```

In the above example, the `defer conn.Close()` statement ensures that the database connection is closed regardless of how the `GetUsername` function exits, whether it returns successfully or encounters an error. This helps prevent resource leaks and ensures proper cleanup of resources.

### Multiple Defer Statements
You can have multiple `defer` statements in a function, and they will be executed in last-in-first-out (LIFO) order. This means that the last `defer` statement will be executed first when the function returns.

```go
func CreateTempFile() {
	f, _ := os.Create("temp-42.txt")
	defer os.Remove(f.Name()) // executed second
	defer f.Close()           // executed first

	fmt.Fprintln(f, "How many roads must a man walk down?")
}
```
In the above example, the `defer f.Close()` statement will be executed first to close the file, and then the `defer os.Remove(f.Name())` statement will be executed to remove the temporary file. This ensures that the file is properly closed before it is deleted.

## Block Scope
In Go, variables declared within a function are only accessible within that function. This is known as block scope. Variables declared in an outer block are not accessible in an inner block, and vice versa.

Like there can be codes where u will see plain old explicit block.
```go
package main

import fmt

func main() {
    {
        age := 19
        // this is okay
        fmt.Println(age)
    }

    // this is not okay
    // the age variable is out of scope
    fmt.Println(age)
}
```

## Closures
A closure is a function that references variables from outside its body. The function can access and modify the variables even after the outer function has finished executing.

```go
func concatter() func(string) string {
	doc := ""
	return func(word string) string {
		doc += word + " "
		return doc
	}
}

func main() {
	harryPotterAggregator := concatter()
	harryPotterAggregator("Mr.")
	harryPotterAggregator("and")
	harryPotterAggregator("Mrs.")
	harryPotterAggregator("Dursley")
	harryPotterAggregator("of")
	harryPotterAggregator("number")
	harryPotterAggregator("four,")
	harryPotterAggregator("Privet")

	fmt.Println(harryPotterAggregator("Drive"))
	// Mr. and Mrs. Dursley of number four, Privet Drive
}
```

## Currying
Function currying is a concept from functional programming and involves partial application of functions. It allows a function with multiple arguments to be transformed into a sequence of functions, each taking a single argument.

```go
func main() {
  squareFunc := selfMath(multiply)
  doubleFunc := selfMath(add)

  fmt.Println(squareFunc(5))
  // prints 25

  fmt.Println(doubleFunc(5))
  // prints 10
}

func multiply(x, y int) int {
  return x * y
}

func add(x, y int) int {
  return x + y
}

func selfMath(mathFunc func(int, int) int) func (int) int {
  return func(x int) int {
    return mathFunc(x, x)
  }
}
```
In the example above, the `selfMath` function takes in a function as its parameter and returns a function that itself returns the value of running that input function on its parameter.
